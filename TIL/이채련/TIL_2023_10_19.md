# TypeScript가 제공하는 타입 시스템 언어 확장에 대한 이해

## 타입 추론 (Types by Inference)

- 변수를 생성하면서 동시에 특정 값에 할당하는 경우
- 해당 값의 타입을 변수의 타입으로 사용한다!

```jsx
let helloWorld = "Hello World";
// helloWorld 의 type은 string
```

## 타입 정의하기 (Defining Types)

- 타입을 미리 정의해둘 수 있다.
- interface를 우선적으로 사용하고, 특정 기능이 필요할 때 type을 사용해야한다.
- interface 를 만들어놓고, :TypeName 구문을 사용해 자바스크립트의 객체가 interface의 형태를 따르고 있음을 선언할 수 있다.

```jsx
interface User {
  name: string;
  id: number;
}
// user 객체 변수는 User 라는 interface를 따른다는 것을 표시
const user: User = {
  name: "Hayes",
  id: 0,
};
```

- 인터페이스(interface)
  - 클래스도 인터페이스를 만들어둘 수 있음
  - 매개변수나 리턴값도 만들 수 있음
- 타입스크립트에서 제공하는 기본 타입과, 확장 타입
  - boolean
  - bigint
  - null
  - number
  - string
  - symbol
  - object
  - undefined
  - any (무엇이든 허용)
  - unknown (이 타입을 사용하는 사람이 타입이 무엇인지 선언했는가를 확인하십시오)
  - never (이 타입은 발생될 수 없습니다)
  - void (`undefined`를 리턴하거나 리턴 값이 없는 함수)

## 타입 구성 (Composing Types)

- 여러가지 타입을 이용해 새 타입을 작성하는 방법
- 유니언 or 제네릭

### 유니언 **(Unions)**

- 타입이 여러 타입 중 하나일 수 있음을 선언하는 방법

```jsx
// boolean 타입을 true 또는 false로 설명할 수 있습니다:
type MyBool = true | false;

// 가장 많이 사용된 사례
// 값이 다음과 같이 허용되는 string 또는 number의 리터럴집합을 설명하는 것
type WindowStates = "open" | "closed" | "minimized";
type LockStates = "locked" | "unlocked";
type OddNumbersUnderTen = 1 | 3 | 5 | 7 | 9;
```

### 제네릭 **(Generics)**

- 타입에 변수를 제공하는 방법
- 예를 들어, 배열이 제네릭을 사용하는 가장 일반적인 예시임.
  - 제네릭이 없는 배열은 어떤 것이든 포함 가능하다.
  - 제네릭이 있는 배열은 배열 안의 값을 설명할 수 있다.
